# 190. 颠倒二进制位

## 题目地址
https://leetcode-cn.com/problems/reverse-bits/

## 题目描述
```

颠倒给定的 32 位无符号整数的二进制位。

注意：

Exmaple1:

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

Exmaple2:

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。
```

## 思路

- 颠倒二进制位，可以使用一个额外的标志，相当于从右至左扫描原二进制数据然后，在模式数据中相乘再相加。若原数据末尾为1，匹配数据*2+ 1;若原数据末尾为0，将匹配数据*2即可。


## 代码
```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        long int revN = 0, num = 32;
        
        while(num--)
        {
            if(n & 1)
                revN = revN * 2 + 1;
            else
                revN *= 2;
            
            n = n >> 1;
        }
        
        return revN;
    }
};
```

# 191. 位1的个数

## 题目地址
https://leetcode-cn.com/problems/number-of-1-bits/

## 题目描述
```
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

Example 1:

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

Example 2:

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

Example 3:

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

```

## 思路

- 本题方法是通过一直遍历二进制数据的最后一位，使用它与1相与得到末尾是否为1的数据。最后再将数字除以2（相当于右移1位）

## 代码
```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int oneNumber = 0;
        while(n)
        {
            if(n & 1)
                oneNumber++;
            
            n = n >> 1;
        }
        
        return oneNumber;
    }
};
```

# 461. 汉明距离

## 题目地址
https://leetcode-cn.com/problems/hamming-distance/

## 题目描述
```
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 231.

Example 1:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。 

```

## 思路

- 首先要把题意理解清楚，题目是说两个二维数字中1的个数不同数目。因此可以采用的方法是异或法，即首先将两个数字进行异或运算（这样不同的元素结果唯1），故可以统计计算后的数字中1的个数即可。每次统计拿当前数字与1进行与运算，然后再向右移动1位（相当于除以2），统计整个数字中1的个数。


## 代码
```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int num = x^y;
        
        int distance = 0;
        while(num > 0)
        {
            if(num & 1)
                distance++;
            
            num = num>>1;
        }
        
        return distance;
    }
};
```
