## 题目地址
https://leetcode-cn.com/problems/reverse-words-in-a-string/

## 题目描述
```
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

Example 1:

输入: "the sky is blue"
输出: "blue is sky the"

Example 2:

输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

Exmaple 3:

输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。


说明：

无空格字符构成一个单词。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

```

## 思路

- 辅助栈法

1.此题主要考察的是栈,所以定义一个辅助栈;

2.先把字符串以"/"为分隔符分割成数组,此时数组有"路径"、""、"."、".."这四种情况;

3.遍历数组,当s[i].equals("..")并且栈不空时pop,当!s[i].equals("") && !s[i].equals(".") && !s[i].equals(".."),即s[i]是路径入栈;

4.栈空,返回"/",栈非空,用StringBuffer做一个连接返回即可;

5.完结。


## 注意事项

- 需要仔细考虑为什么采用双指针法能够求得最大值！

## 代码
```java
// java
class Solution {
    public String simplifyPath(String path) {
        String[] s = path.split("/");   // 将字符串以"/"为间隔将其分割
        Stack<String> stack = new Stack<>();
        
        for(int i = 0; i < s.length; i++){
            if(!stack.isEmpty() && s[i].equals("..")){
                stack.pop();  // 对于".."的形式使其出栈
            }else if(!s[i].equals(".") && !s[i].equals("") && !s[i].equals("..")){
                stack.push(s[i]);  // 满足题目要求的字符将其入栈
            }
        }
        
        if(stack.isEmpty())
            return "/";
        
        StringBuffer res = new StringBuffer();
        for(int i = 0; i < stack.size(); i++){
            res.append("/" + stack.get(i));  // 最后将栈中的字符重新提取组合
        }
        
        return res.toString();
    }
}
```
